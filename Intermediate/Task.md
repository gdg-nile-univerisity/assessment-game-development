**FPS Parkour**
Momentum, Movement & Level Design
üéØ Objective

Create a first-person parkour game where the fun comes from movement and level design, not combat.

This challenge evaluates:

FPS movement systems

Physics-based mechanics

Intentional level design

Code structure & iteration

üéÆ Core Game Concept

The player completes movement-focused levels using speed, flow, and precision.

Combat is optional.
Movement mastery is mandatory.

‚úÖ Mandatory Gameplay Features
1Ô∏è‚É£ Core FPS Movement (Required üî¥)

Mouse look

WASD movement

Jump with air control

Momentum preservation

Movement must feel smooth and responsive.

2Ô∏è‚É£ Parkour Mechanics (Required üî¥)

You must implement at least 3 of the following:

Wall running

Sliding (momentum-based)

Wall jumping

Vaulting

Ledge grabbing

Grapple hook

Each mechanic must:

Have clear entry/exit conditions

Preserve or modify momentum intentionally

Be reusable across levels

3Ô∏è‚É£ Level Design Focus 

You must create 2‚Äì4 handcrafted levels designed around:

Teaching mechanics naturally

Flow and movement lines

Risk vs reward paths

Skill expression

Each level must include:

A clear start & end

Multiple possible routes (fast vs safe)

Visual guidance (lighting, geometry, color)

Procedual levels are allowed

4Ô∏è‚É£ Time / Score System

Level completion time OR

Speed-based scoring system

Persistent best time / score per level

This encourages replayability and mastery.

5Ô∏è‚É£ Checkpoints & Restart

Mid-level checkpoints

Instant restart

No long reload times

üé® Creativity & Design Depth

Your game must have a strong identity:
You can use any theme of your choice

üß© Code Architecture Requirements

You must demonstrate:

Modular movement system

Clear separation:

Input

Movement logic

Camera

UI

Minimal hard-coding

Suggested components:

PlayerController

MovementStateMachine

LevelManager

CheckpointSystem

TimeTrialManager

The Grading System (100 Points Total)
Each task is graded out of 100 points, broken down into two main categories:

A. Technical Implementation & Functionality (60 Points)
Core Requirements Met (25 pts): Does the submitted project do what was asked?

Code Quality & Architecture (20 pts): Is the code clean, well-structured, and scalable?

Error Handling & Robustness (10 pts): Does it handle edge cases gracefully?

Performance & Optimization (5 pts): Is it efficient? (FPS, memory, etc.)

B. GitHub & Development Process (40 Points)
Commit History (15 pts): Small, logical, and descriptive commits.

Branching & Pull Requests (10 pts): Use of feature branches and clear PR descriptions.

Use of Issues/Project Board (10 pts): Breaking down the task into manageable parts.

README & Documentation (5 pts): Clear setup and project explanation.




